<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>jULIANT: julian::SimulatedAnnealing Class Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="juliant.css" rel="stylesheet" type="text/css"/>
<link href="bootstrap_custom.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">jULIANT 0.99</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>julian</b></li><li class="navelem"><a class="el" href="a00181.html">SimulatedAnnealing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="a00696.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">julian::SimulatedAnnealing Class Reference<div class="ingroups"><a class="el" href="a00568.html">Mathematics</a> &raquo; <a class="el" href="a00571.html">Numerical Algorithms</a> &raquo; <a class="el" href="a00572.html">Optimization algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class implements Simulated Annealing minimizer.  
 <a href="a00181.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00469_source.html">simulatedAnnealing.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac76a2e0019703f997d10958cb7039046"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html#ac76a2e0019703f997d10958cb7039046">SimulatedAnnealing</a> (<a class="el" href="a00182.html">SmartPointer</a>&lt; <a class="el" href="a00194.html">UniformRNG</a> &gt; rng, <a class="el" href="a00182.html">SmartPointer</a>&lt; <a class="el" href="a00167.html">RandomVariable</a> &gt; rand)</td></tr>
<tr class="memdesc:ac76a2e0019703f997d10958cb7039046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ac76a2e0019703f997d10958cb7039046">More...</a><br /></td></tr>
<tr class="separator:ac76a2e0019703f997d10958cb7039046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4d7f7074b0e482199f6bf313623708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html#a5b4d7f7074b0e482199f6bf313623708">setCoolingSchedule</a> (const std::vector&lt; double &gt; &amp;cooling_schedule)</td></tr>
<tr class="memdesc:a5b4d7f7074b0e482199f6bf313623708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set cooling schedule.  <a href="#a5b4d7f7074b0e482199f6bf313623708">More...</a><br /></td></tr>
<tr class="separator:a5b4d7f7074b0e482199f6bf313623708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b671c3341161f2e6bf2be8c9a711b72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html#a4b671c3341161f2e6bf2be8c9a711b72">setLinearCooling</a> (double Tstart, double Tend, double param)</td></tr>
<tr class="memdesc:a4b671c3341161f2e6bf2be8c9a711b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates linear cooling schedule.  <a href="#a4b671c3341161f2e6bf2be8c9a711b72">More...</a><br /></td></tr>
<tr class="separator:a4b671c3341161f2e6bf2be8c9a711b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7667766db8736d302f7ee88090150a0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html#a7667766db8736d302f7ee88090150a0c">setExponentialCooling</a> (double Tstart, double Tend, double param)</td></tr>
<tr class="memdesc:a7667766db8736d302f7ee88090150a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates exponential cooling schedule.  <a href="#a7667766db8736d302f7ee88090150a0c">More...</a><br /></td></tr>
<tr class="separator:a7667766db8736d302f7ee88090150a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1345f9b31b8139a2cddc75721b80b23"><td class="memTemplParams" colspan="2">template&lt;typename F , typename PA &gt; </td></tr>
<tr class="memitem:ad1345f9b31b8139a2cddc75721b80b23"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00181.html#ad1345f9b31b8139a2cddc75721b80b23">calculate</a> (F f, PA prob_accept, double x_initial, int iters_per_t)</td></tr>
<tr class="memdesc:ad1345f9b31b8139a2cddc75721b80b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method finds the minimum of provided function.  <a href="#ad1345f9b31b8139a2cddc75721b80b23">More...</a><br /></td></tr>
<tr class="separator:ad1345f9b31b8139a2cddc75721b80b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d1e79a4b6fd54fd66d4d6e8c8fcb9b"><td class="memTemplParams" colspan="2">template&lt;typename F , typename PA &gt; </td></tr>
<tr class="memitem:a04d1e79a4b6fd54fd66d4d6e8c8fcb9b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00181.html#a04d1e79a4b6fd54fd66d4d6e8c8fcb9b">calculate</a> (F f, PA prob_accept, std::vector&lt; double &gt; x_initial, int iters_per_t)</td></tr>
<tr class="memdesc:a04d1e79a4b6fd54fd66d4d6e8c8fcb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method finds the minimum of provided function.  <a href="#a04d1e79a4b6fd54fd66d4d6e8c8fcb9b">More...</a><br /></td></tr>
<tr class="separator:a04d1e79a4b6fd54fd66d4d6e8c8fcb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfcab77bfeb65b26936f035cc29821d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html#a1dfcab77bfeb65b26936f035cc29821d">takeStep</a> (double x)</td></tr>
<tr class="memdesc:a1dfcab77bfeb65b26936f035cc29821d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the new state.  <a href="#a1dfcab77bfeb65b26936f035cc29821d">More...</a><br /></td></tr>
<tr class="separator:a1dfcab77bfeb65b26936f035cc29821d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5e02ebae703e4fcf9af33e4a54f74d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html#afa5e02ebae703e4fcf9af33e4a54f74d">takeStep</a> (std::vector&lt; double &gt; x)</td></tr>
<tr class="memdesc:afa5e02ebae703e4fcf9af33e4a54f74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the new state.  <a href="#afa5e02ebae703e4fcf9af33e4a54f74d">More...</a><br /></td></tr>
<tr class="separator:afa5e02ebae703e4fcf9af33e4a54f74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef52f829ed4b7c8058181e43d66cf53e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html#aef52f829ed4b7c8058181e43d66cf53e">~SimulatedAnnealing</a> ()</td></tr>
<tr class="memdesc:aef52f829ed4b7c8058181e43d66cf53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aef52f829ed4b7c8058181e43d66cf53e">More...</a><br /></td></tr>
<tr class="separator:aef52f829ed4b7c8058181e43d66cf53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a140640bae956ae30bf6c1a3c9a5c0cfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00182.html">SmartPointer</a>&lt; <a class="el" href="a00167.html">RandomVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html#a140640bae956ae30bf6c1a3c9a5c0cfa">step_</a></td></tr>
<tr class="memdesc:a140640bae956ae30bf6c1a3c9a5c0cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribution used in picking of neighbour state.  <a href="#a140640bae956ae30bf6c1a3c9a5c0cfa">More...</a><br /></td></tr>
<tr class="separator:a140640bae956ae30bf6c1a3c9a5c0cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea90862ac637c08297a71ab98a76655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00182.html">SmartPointer</a>&lt; <a class="el" href="a00194.html">UniformRNG</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html#a7ea90862ac637c08297a71ab98a76655">rng_</a></td></tr>
<tr class="memdesc:a7ea90862ac637c08297a71ab98a76655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator used in acceptance of new state.  <a href="#a7ea90862ac637c08297a71ab98a76655">More...</a><br /></td></tr>
<tr class="separator:a7ea90862ac637c08297a71ab98a76655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e566fc7f3b24229a113d486e79bda34"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html#a4e566fc7f3b24229a113d486e79bda34">cooling_schedule_</a></td></tr>
<tr class="memdesc:a4e566fc7f3b24229a113d486e79bda34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooling schedule.  <a href="#a4e566fc7f3b24229a113d486e79bda34">More...</a><br /></td></tr>
<tr class="separator:a4e566fc7f3b24229a113d486e79bda34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class implements Simulated Annealing minimizer. </p>
<p>Simulating annealing is a stochastic algorithm used to solve optimization problems.</p>
<p>Quoting authors of <b>Numerical</b> <b>Recipes</b> (Chapter 10.9 <a class="el" href="a00583.html#CITEREF_NumRec">[4]</a>):</p>
<p><em>At the heart of the method of simulated annealing is an analogy with thermodynamics, specifically with the way that liquids freeze and crystallize, or metals cool and anneal. At high temperatures, the molecules of a liquid move freely with respect to one another. If the liquid is cooled slowly, thermal mobility is lost. The atoms are often able to line themselves up and form a pure crystal that is completely ordered over a distance up to billions of times the size of an individual atom in all directions. This crystal is the state of minimum energy for this system.</em></p>
<p>The pseudo-code of simulated annealing's algorithm is presented below: </p><pre class="fragment">x = initial guess
x_best = x
E = f(x)
E_best = E
for temperature in cooling_schedule:
    iter = 0
    while iter &lt; maximum number of steps:
       x_new = pick a neighbour of x
       E_new = f(x_new) 

       if E_new &lt;= E_best:
           x_best = x_new
           E_best = E_new
       
       if E_new &lt; E:
           x = x_new
           E = E_new
       else if ( U(0,1) &lt; acceptance_probability(E, E_new, T)
           x = x_new
           E = E_new
        
   iter++
</pre><p>Cooling schedule is a series of decreasing real numbers. The <em>temperature</em> influences the acceptance probability. For more details see <a class="el" href="a00583.html#CITEREF_coolingschemes">[46]</a></p>
<p>The neighbour is picked from distribution provided by user. The distribution expected value should be equal to zero. Usually it is a normal or uniform distribution.</p>
<p>Acceptance probability is the probability of moving to a new state. If new steps is a step of lower energy the probability of taking the step is 1.0. In other case the probability is calculated using the acceptance probability function and compared to randomly picked number from standard uniform distribution. It means that algorithm can choose the non-optimal state, what makes the algorithm immune to local minimums. Larger increases in energy of the system should be less probably. The probability of such steps should decrease with temperature of the system. Kirkpatrick et al. choose the Boltzmann distribution: <img class="formulaInl" alt="$p = e^{-(E_{new} - E)/(kT)}$" src="form_176.png"/> , justified by analogy with the transitions of a physical systems. It also corresponds to the Metropolis–Hastings algorithm (see <a class="el" href="a00583.html#CITEREF_hastings">[44]</a>). The implemented algorithm enables usage of any acceptance probability.</p>
<p>For more details see also: <a class="el" href="a00583.html#CITEREF_physicsmontecarlo">[11]</a> <a class="el" href="a00583.html#CITEREF_Sherer">[33]</a> <a class="el" href="a00583.html#CITEREF_simAnneal1">[38]</a> </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00031.html#_a3">simulatedAnnealingExample.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac76a2e0019703f997d10958cb7039046"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">julian::SimulatedAnnealing::SimulatedAnnealing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00182.html">SmartPointer</a>&lt; <a class="el" href="a00194.html">UniformRNG</a> &gt;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00182.html">SmartPointer</a>&lt; <a class="el" href="a00167.html">RandomVariable</a> &gt;&#160;</td>
          <td class="paramname"><em>rand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="aef52f829ed4b7c8058181e43d66cf53e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">julian::SimulatedAnnealing::~SimulatedAnnealing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad1345f9b31b8139a2cddc75721b80b23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename PA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double julian::SimulatedAnnealing::calculate </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PA&#160;</td>
          <td class="paramname"><em>prob_accept</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iters_per_t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method finds the minimum of provided function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>One-dimensional function which optimum we are looking for. f should be a functor. </td></tr>
    <tr><td class="paramname">prob_accept</td><td>Probability acceptance function </td></tr>
    <tr><td class="paramname">x_initial</td><td>Initial guess </td></tr>
    <tr><td class="paramname">iters_per_t</td><td>Number of iterations taken for each temperature value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the x for which function f obtains its minimum </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00031.html#a5">simulatedAnnealingExample.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a04d1e79a4b6fd54fd66d4d6e8c8fcb9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename PA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; julian::SimulatedAnnealing::calculate </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PA&#160;</td>
          <td class="paramname"><em>prob_accept</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>x_initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iters_per_t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method finds the minimum of provided function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Multi-dimensional function which optimum we are looking for. f should be a functor. </td></tr>
    <tr><td class="paramname">prob_accept</td><td>Probability acceptance function </td></tr>
    <tr><td class="paramname">x_initial</td><td>Initial guess </td></tr>
    <tr><td class="paramname">iters_per_t</td><td>Number of iterations taken for each temperature value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the x for which function f obtains its minimum </dd></dl>

</div>
</div>
<a class="anchor" id="a5b4d7f7074b0e482199f6bf313623708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void julian::SimulatedAnnealing::setCoolingSchedule </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>cooling_schedule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set cooling schedule. </p>

</div>
</div>
<a class="anchor" id="a7667766db8736d302f7ee88090150a0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void julian::SimulatedAnnealing::setExponentialCooling </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Tstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Tend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates exponential cooling schedule. </p>
<p>Cooling schedule is calculating basing on Tstart, Tend and step provided by an user. The Schedule is <img class="formulaInl" alt="$[T_{start}, \frac{T_{start}}{\text{step}}, \frac{T_{start}}{\text{step}^2}, \frac{T_{start}}{\text{step}^3},..., T_{end} ]$" src="form_175.png"/> </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00031.html#a4">simulatedAnnealingExample.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4b671c3341161f2e6bf2be8c9a711b72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void julian::SimulatedAnnealing::setLinearCooling </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Tstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Tend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates linear cooling schedule. </p>
<p>Cooling schedule is calculating basing on Tstart, Tend and step provided by an user. The Schedule is <img class="formulaInl" alt="$[T_{start}, T_{start} - \text{step}, T_{start} - 2\text{step}, T_{start}-3\text{step},..., T_{end} ]$" src="form_174.png"/> </p>

</div>
</div>
<a class="anchor" id="a1dfcab77bfeb65b26936f035cc29821d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double julian::SimulatedAnnealing::takeStep </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the new state. </p>

</div>
</div>
<a class="anchor" id="afa5e02ebae703e4fcf9af33e4a54f74d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; julian::SimulatedAnnealing::takeStep </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the new state. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a4e566fc7f3b24229a113d486e79bda34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; julian::SimulatedAnnealing::cooling_schedule_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooling schedule. </p>

</div>
</div>
<a class="anchor" id="a7ea90862ac637c08297a71ab98a76655"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00182.html">SmartPointer</a>&lt;<a class="el" href="a00194.html">UniformRNG</a>&gt; julian::SimulatedAnnealing::rng_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random number generator used in acceptance of new state. </p>

</div>
</div>
<a class="anchor" id="a140640bae956ae30bf6c1a3c9a5c0cfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00182.html">SmartPointer</a>&lt;<a class="el" href="a00167.html">RandomVariable</a>&gt; julian::SimulatedAnnealing::step_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distribution used in picking of neighbour state. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Unix/home/OEM/jULIAN/src/mathematics/numericalAlgorithms/<a class="el" href="a00469_source.html">simulatedAnnealing.hpp</a></li>
<li>C:/Unix/home/OEM/jULIAN/src/mathematics/numericalAlgorithms/simulatedAnnealing.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 26 2018 01:32:17 for jULIANT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
