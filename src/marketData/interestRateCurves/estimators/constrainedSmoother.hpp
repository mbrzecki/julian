#ifndef JULIAN_IRCONSTRAINEDSMOOTHER_HPP
#define JULIAN_IRCONSTRAINEDSMOOTHER_HPP

#include <marketData/interestRateCurves/estimators/costFunctions/SmootherCostFunction.hpp>
#include <marketData/interestRateCurves/curveBuildingBlock.hpp>
#include <marketData/interestRateCurves/estimators/irCurveEstimator.hpp>
#include <dates/date.hpp>
#include <dates/tenor.hpp>

namespace julian {
namespace ir {

  /**
   * @file   constrainedSmoother.hpp
   * @brief  File contains definition of constrained smoothing bootstrapper.
   */
  
  /** \ingroup irCurveEstimator
   *  \brief Class implements 
   *
   * The idea of this estimator is to find the minimum of function (see SmootherCostFunction)
   * \f[Cost_{f} = a \int^{tN}_{t0} \Big(\frac{df(x)}{dx}\Big)^2 dx + b \int^{tN}_{t0} \Big(\frac{df^2(x)}{dx^2}\Big)^2 dx \f]
   * with following constrains:
   * \f[q_i -tolerante_{lower} < r_i < q_i + tolerance_{upper}\f]
   * where:
   * * \f$q_i\f$
   *
   * \todocument Describe the algorithm more precisly
   */
  class ConstrainedSmoother: public Estimator {
  public:
    ConstrainedSmoother(SmartPointer<SmootherCostFunction> cf, const std::vector<double>& lT, const std::vector<double>& uT, int number_of_iterations);
    ConstrainedSmoother(SmartPointer<SmootherCostFunction> cf, double tolerance, int number_of_iterations);
    
    virtual void calculate(const std::vector<SmartPointer<BuildingBlock> >& instruments, const CurveSettings& settings,
			   SmartPointer<ir::Curve>& discounting_curve, SmartPointer<ir::Curve>& projection_curve);
    virtual std::vector<double> getDF() const;
    virtual std::vector<Date> getDates() const;
    virtual ConstrainedSmoother* clone() const;

    virtual std::string info() const;
      
    virtual ~ConstrainedSmoother(){};
      
  private:
    arma::mat calculateJacobian(SmartPointer<ir::Curve>, SmartPointer<ir::Curve>, InterpolatedCurve, const std::vector<SmartPointer<BuildingBlock> >&);  
    arma::mat calculateParRates(const SmartPointer<ir::Curve>&, const SmartPointer<ir::Curve>&, const SmartPointer<ir::Curve>&, const std::vector<SmartPointer<BuildingBlock> >&);
  
    SmartPointer<SmootherCostFunction> cost_function_;/*!< @brief Cost Function */ 
    std::vector<double> lower_tolerance_; /*!< @brief Lower tolerances for par rate generated by curve
					   
					   The tolerances are set for each instrument separately. The n-th number in vector is applied to n-th instrument 
					   */
    std::vector<double> upper_tolerance_; /*!< @brief Upper tolerances for par rate generated by curve */
    int number_of_iterations_; /*!< @brief Number of iterations of Sequential Quadratic Programming */
    double tolerance_; /*!< @brief Tolerance for par rate generated by curve
			 
			 \details Applied to all instruments. The par rate implied from the curve will be in range (quote - tolerance, quote + tolerance)*/
      
    std::vector<double> DFs_;  /*!< @brief Vector holding the Discount Factors being result of estimation*/
    std::vector<Date> dates_; /*!< @brief Grid dates of resulting curve*/
  };
}  // namespace ir
}  // namespace julian

#endif /* IRCONSTRAINEDSMOOTHER_HPP */
